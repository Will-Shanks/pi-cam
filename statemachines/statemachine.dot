digraph {

  a_s->{s_a_g_fps, s_a_s_fps, s_a_g_res, s_a_s_res, s_a_stop, s_a_start}
  a_s->{r_a_g_fps, r_a_s_fps, r_a_g_res, r_a_s_res, r_a_stop, r_a_stop}
  a_s->{d_a_start, d_a_stop}
  a_stop->k [color=red]
  k [label="Off", style=filled, fillcolor=black, fontcolor=white]
  k->a_a_start [label="Powered On", color=green]
  a_a_stop->{a_stop, s_a_stop, r_a_stop, d_a_stop} [color=red]
  a_a_start->{r_a_start,s_a_start}

subgraph cluster_a {
  label="Main Control Thread"
  a_a_start->a_a [label="New Thread", color=blue]
  a_a->a_c [label="Connection established"]
  a_c->a_d [label="Recieved Request"]
  a_d->a_s [label="Request Decoded"]
  a_s->a_a_stop
  a_s->a_c [label="Request Serviced"]
  {a_c, a_d, a_s}->a_clean [label="Connection Terminated"]
  a_clean->a_a

  a_a [label="Listening for TCP connection on port A_PORT"]
  a_c [label="Read Request from connection"]
  a_d [label="Decode Request"]
  a_s [label="Service Request"]
  a_clean [label="Clean up Connection"]
  a_stop [label="Close Socket"]

  subgraph cluster_a_a {
    label="Main API"
    a_a_start [label="Start Everything", shape=box]
    a_a_stop [label="Poweroff", shape=box]
  }

}
  r_a_start->g_a_start
  r_a_stop->g_a_stop
  r_stop->d [color=red]
  d [label="Kill Thread", style=filled, fillcolor=grey]
subgraph cluster_r {
  label="Recorder"
  r_a_start->r_open [label="New Thread", color=blue]
  r_open->r_r
  r_r->r_close [label="time/R_INTERVAL != Recording File name"]
  r_close->r_open [label="R_UPDATE=False"]
  r_close->r_restart [label="R_UPDATE=True"]
  r_restart->r_open

  r_a_stop->r_stop [label="Signal Thread", style=dashed, color=red]

  r_a_s_fps->r_update [label="new FPS != old FPS"]
  r_a_s_res->r_update [label="new RES != old RES"]

  r_r [label="Record and Save Video"]
  r_update [label="Set R_UPDATE=True"]
  r_close [label="Close (old) Recording File"]
  r_open [label="Open Recording File"]
  r_restart [label="Restart Recording with current R_FPS and R_RES"]
  r_stop [label="Stop Recording, Close Recording File"]

  subgraph cluster_r_a {
    label="Recorder API"    
    r_a_g_fps [label="Get R_FPS", shape=box]
    r_a_s_fps [label="Set R_FPS", shape=box]
    r_a_g_res [label="Get R_RES", shape=box]
    r_a_s_res [label="Set R_RES", shape=box]
    r_a_start [label="Start", shape=box]
    r_a_stop [label="Stop", shape=box]
  }
}
  g_a_stop->d [color=red]
subgraph cluster_g{
  label="Memory Manager"
  g_a_start->g_g [label="New Thread", color=blue]
  g_g->g_d [label="<MIN_FREE_MEM"]
  g_d->g_g
  g_g->g_s [label=">MIN_FREE_MEM"]
  g_s->g_g


  g_g [label="", shape=point]
  g_d [label="Delete oldest recording"]
  g_s [label="Sleep R_INTERVAL/2"]

  subgraph cluster_g_a {
    label="Memory Manager API"
    g_a_start [label="Start", shape=box]
    g_a_stop [label="Stop", shape=box]
  }
}
  d_clean->d [color=red]
subgraph cluster_d {
  label="Downloader"
  d_a_start->d_d [label="New Thread", color=blue]
  d_d->d_s [label="Connection established"]
  d_s->d_clean [label="Request Serviced/Connection Terminated"]

  d_a_stop->d_clean [label="Signal Thread", color=red, style=dashed]

  d_d [label="Listen for TCP connection on port D_PORT"]
  d_s [label="Write request to connection"]
  d_clean [label="Close Socket, Recording File"]

  subgraph cluster_d_a{
    label="Downloader API"
    d_a_start [label="Request Download", shape=box]
    d_a_stop [label="Cancel Download", shape=box]
  }
}
  s_d->d [color=red]
subgraph cluster_s {
  label="Streamer"
  s_a_start->s_s [label="New Thread", color=blue]
  s_s->s_c [label="Connection established"]
  s_c->s_close [label="Connection Terminated"]
  s_close->s_s

  s_a_stop->s_d [label="Signal Thread", style=dashed, color=red]

  s_a_s_fps->s_restart [label="If new FPS != old FPS, Signal Thread", style=dashed]

  s_a_s_res->s_restart [label="If new RES != old RES, Signal Thread", style=dashed]

  s_s [label="Listen for UDP connection on port S_PORT"]
  s_c [label="Record and Stream over connection"]
  s_restart [label="Restart Recording with current S_FPS and S_RES"]
  s_d [label="Close Socket"]
  s_close [label="Clean up Connection"]

  subgraph cluster_s_a {
    label="Streamer API"
      s_a_g_fps [label="Return S_FPS", shape=box]
      s_a_s_fps [label="Set S_FPS", shape=box]
      s_a_g_res [label="Return S_RES", shape=box]
      s_a_s_res [label="Set S_RES", shape=box]
      s_a_stop [label="Stop", shape=box]
      s_a_start [label="Start", shape=box]
  }
}
}
